<!DOCTYPE html><html class="dark"><head><meta charset="utf-8"><title>Unordered Function Application In Haskell</title><meta name="og:title" content="Unordered Function Application In Haskell"><meta property="og:site_name" content="mgsloan"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="treetopian"><link href="/favicon.png" rel="icon" type="image/png"><link href="/feed.xml" rel="alternate" type="application/atom+xml"><link href="https://mgsloan.com/posts/unordered-apply" rel="canonical"><meta name="description" content="Fancy type system tricks to implement type-directed function application."><meta name="og:description" content="Fancy type system tricks to implement type-directed function application."><meta name="author" content="Michael G Sloan"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="https://fonts.googleapis.com/css?family=Alegreya:700|Alegreya+Sans:400,400i,700|Alegreya+Sans+SC:400|Inconsolata:400,700|Playfair+Display:400,700" rel="stylesheet"><style>*{margin:0;padding:0}code,em,strong{line-height:1}html{font-size:16px;zoom:1.15;background-color:#234}body{background-color:#fffef8;padding-top:0.2em;color:#456;font-family:'Alegreya Sans',sans-serif;font-feature-settings:'liga','kern';line-height:1.6}#content,#teaser,#footer{padding:1.4em;margin-left:auto;margin-right:auto;max-width:36em}#content{padding-top:0;min-height:-moz-available;min-height:-webkit-fill-available;min-height:fill-available}header{font-family:'Playfair Display',sans;margin-left:1em;margin-right:1em;overflow:visible;text-align:center;margin-bottom:1.0em}h1{font-family:'Playfair Display',serif;color:#000;font-size:1.8em;line-height:3.8rem;margin-bottom:0.7rem;padding-top:2.8rem}header>h2{font-feature-settings:'dlig';font-size:1.4em;font-style:italic;font-weight:normal;line-height:1.4rem;margin-bottom:1.0rem;padding-top:0.4rem}header>p{padding-top:0.5em;padding-bottom:0.9em;margin-bottom:0}article>header>hr.hairline{margin-top:0.5em;transform:scale(1.3,0.5)}article hr.hairline{transform:scale(1.09,0.5)}hr.hairline{border:none;border-bottom:1px solid #c35;transform:scale(1,0.5)}.footnotes-divider{margin-top:3.4em;margin-bottom:2.4em}h1>br{display:none}p,nav{margin-bottom:1em;padding-top:0.4em}a{color:#c35;text-decoration:none}abbr,.smcp{font-family:"Alegreya Sans SC";letter-spacing:0.1em;display:inline-block}abbr{letter-spacing:0.03em;margin-right:-0.03em}.run-in{font-family:"Alegreya Sans SC";letter-spacing:0.05em}h2{font-family:Alegreya,serif;font-size:1.4em;line-height:1em;margin-bottom:0.2rem;padding-top:1.2rem}h2>a:before{content:'¶';width:1.2rem;margin-left:-1.2rem;display:inline-block;opacity:0;transition:opacity 0.2s ease-out;color:#b4aaaa}h2:hover>a:before{opacity:1}h2:target>a:before{opacity:1;color:#c35}ul,ol{counter-reset:ol;list-style:none;margin-top:1em}li{position:relative}li:before{display:inline-block;margin-left:-1em;width:1em;position:absolute;top:0}ul>li:before{content:'•';font-weight:bold;transform:scale(1.6);top:-0.15em}ul.affiliate>li:before{content:'$';transform:scale(1)}ol>li:before{content:counter(ol,decimal);counter-increment:ol;font-weight:bold;top:-0.05em}li>p:first-child{display:inline-block;padding-top:0}li>p:first-child + *{margin-top:0}li>ul,li>ol{margin-left:1em}li>ul>li:before{content:"■";transform:scale(0.5);top:-0.05em}table{border-spacing:0;margin-bottom:1em;margin-left:auto;margin-right:auto;text-align:left}th{padding-top:0.4em}th,td{padding-right:1.4em;vertical-align:top}code{font-family:Inconsolata,monospace;word-break:break-word;background-color:rgba(27,31,35,0.07);padding:0.2em}pre>code{background-color:transparent;padding:0}pre{border:1px solid #4568;color:#456;margin-bottom:0.6rem;margin-top:0.2rem;overflow-x:auto;padding:1rem;padding-left:1.4rem;margin-left:-1.4rem;margin-right:-1.4rem;font-size:0.9rem;line-height:1.4rem}pre:hover{overflow-x:auto}::-webkit-scrollbar{background-color:#fffef8}::-webkit-scrollbar-track{background-color:#fffef8}::-webkit-scrollbar-thumb{background-color:#c35}pre::-webkit-scrollbar-thumb{background-color:#fffef8}pre:hover::-webkit-scrollbar-thumb{background-color:#c35}.kw,.cf{color:#07a}.dt,.at{color:#d56}.op{color:#690}.dv,.bn,.fl,.er{color:#905}.ch,.st{color:#d80}.co{color:#789}blockquote{font-style:italic;padding-left:1em;padding-right:1em}sup,sub{vertical-align:baseline;position:relative}sup{top:-0.4em}sub{top:0.4em}#teaser-section{background-color:#c35;color:#f5b2c8}#teaser p:first-child{margin-bottom:0.3em}#teaser a{color:#fff;font-family:Alegreya,serif;line-height:0}#teaser a:after{color:#fff;content:'\a0»'}#teaser>h2{margin-bottom:0.2rem;padding-top:0.5rem}footer{background-color:#234;color:#b4aaaa}#notices{clear:both;text-align:center;padding-top:1.8em;display:block}#profile-links{clear:both;text-align:center;margin-left:2.5em;display:block}footer span{margin-left:0.25em;margin-right:0.25em}@media(min-width:400px){#content,#teaser,#footer{padding-left:2em;padding-right:2em}h1{font-size:2.0em}}@media(min-width:470px){html{font-size:16px}header{margin-left:2.8em;margin-right:2.8em}}@media(min-width:544px){#content,#teaser,#footer{padding-left:2.8em;padding-right:2.8em}li{margin-left:0}}@media(min-width:625px){html{font-size:17px}h1>br{display:block}h2>a:before{width:1.6rem;margin-left:-1.6rem}}@media(min-width:802px){html{font-size:18px}h1{font-size:2.4em}header{margin-top:1.4em}}@media(min-width:1003px){html{font-size:19px}h1{font-size:2.6em}}@media(min-width:1225px){#footer{max-width:42em}footer h2{margin-left:3rem}footer nav{float:left;text-align:right;width:6em;margin-left:-5em}#about{float:right;width:36em;margin-right:3em}}@media(max-width:399px){article li:before{margin-left:-0.5em}}@media(max-width:490px){#breakdot{display:block;height:0;overflow:hidden;width:0}li:before{margin-left:-0.95em}#profile-links{margin-left:0}}@media (-webkit-min-device-pixel-ratio:2),(min-device-pixel-ratio:2),(min-resolution:192dpi){pre{border-width:0.5px}}.dark body,.dark ::-webkit-scrollbar,.dark ::-webkit-scrollbar-track,.dark pre::-webkit-scrollbar-thumb{background-color:#1a2633;color:#eee}.dark h1,.dark h2,.dark h3,.dark h2>a:before{color:#fff}.dark .archive h2{}.dark code{background-color:#eee2}.dark pre{border:1px solid #97a8ba;color:#97a8ba}.dark pre>code{background-color:transparent}.dark a{color:#e05271}.dark hr.hairline{border-bottom:1px solid #e05271}.dark .kw,.dark .cf{color:#07a}.dark .dt,.dark .at{color:#d56}.dark .op{color:#690}.dark .dv,.dark .bn,.dark .fl,.dark .er{color:#e6007e}.dark .ch,.dark .st{color:#d80}.dark .co{color:#789}dark-mode-toggle{position:fixed;top:0;right:0;transform:scale(1.5)}dark-mode-toggle input{outline:none}</style><script async src="https://www.googletagmanager.com/gtag/js?id=UA-126869629-1"></script><script>window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-126869629-1');</script></head><body><article id="content" itemscope><header><h1>Unordered Function Application In Haskell</h1><p><a href="/" class="author">mgsloan</a><br><time datetime="2021-04-03" itemprop="datePublished">2021-04-03</time></p><hr class="hairline"></header><p><span class="run-in">Here is a little puzzle:</span> How might a function like <code>reorderArgs</code> be defined, such that the code below compiles?</p><div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">import</span> <span class="dt">Control.Apply.Unordered.Mono</span> (reorderArgs)</span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="co">-- Each example in this group is equal to "hello"</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="co">--</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="co">-- T.cons :: Char -&gt; T.Text -&gt; T.Text</span></span>
<span id="cb1-8"><a href="#cb1-8"></a></span>
<span id="cb1-9"><a href="#cb1-9"></a>ex1 <span class="ot">=</span> T.cons <span class="ch">'h'</span> ello</span>
<span id="cb1-10"><a href="#cb1-10"></a>ex2 <span class="ot">=</span> reorderArgs T.cons <span class="ch">'h'</span> ello</span>
<span id="cb1-11"><a href="#cb1-11"></a>ex3 <span class="ot">=</span> reorderArgs T.cons ello <span class="ch">'h'</span></span>
<span id="cb1-12"><a href="#cb1-12"></a></span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="co">-- Each example in this group is equal to "hhhello".</span></span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="co">--</span></span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="co">-- T.justifyRight :: Int -&gt; Char -&gt; T.Text -&gt; T.Text</span></span>
<span id="cb1-16"><a href="#cb1-16"></a></span>
<span id="cb1-17"><a href="#cb1-17"></a>ex4 <span class="ot">=</span> T.justifyRight seven <span class="ch">'h'</span> ello</span>
<span id="cb1-18"><a href="#cb1-18"></a>ex5 <span class="ot">=</span> reorderArgs T.justifyRight ello <span class="ch">'h'</span> seven</span>
<span id="cb1-19"><a href="#cb1-19"></a>ex6 <span class="ot">=</span> reorderArgs T.justifyRight <span class="ch">'h'</span> ello seven</span>
<span id="cb1-20"><a href="#cb1-20"></a></span>
<span id="cb1-21"><a href="#cb1-21"></a><span class="ot">ello ::</span> <span class="dt">T.Text</span></span>
<span id="cb1-22"><a href="#cb1-22"></a>ello <span class="ot">=</span> <span class="st">"ello"</span></span>
<span id="cb1-23"><a href="#cb1-23"></a></span>
<span id="cb1-24"><a href="#cb1-24"></a><span class="ot">seven ::</span> <span class="dt">Int</span></span>
<span id="cb1-25"><a href="#cb1-25"></a>seven <span class="ot">=</span> <span class="dv">7</span></span></code></pre></div><p>I found it quite surprising that this is possible to define. One thing that makes it feasible is a restriction that all arguments are monomorphic. Solving this puzzle is a decent didactic exercise, as it involves a variety of type-level techniques:</p><ol><li><p>Using <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/exts/type_families.html#closed-type-families">closed type families</a> to direct instance selection.</p></li><li><p>Using <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/exts/type_errors.html">custom type errors</a> to improve the error messaging.</p></li><li><p>Using typeclasses to implement <a href="http://okmij.org/ftp/Haskell/polyvariadic.html">polyvariadic functions</a>.</p></li></ol><p><strong>1</strong> is described in this post. <strong>2</strong> and <strong>3</strong> will be described in subsequent posts in the series.</p><p>The functionality described in these posts is available on Hackage, in the <a href="http://hackage.haskell.org/package/apply-unordered-mono">apply-unordered-mono package</a>. It is also possible to generalize this to polymorphic functions, via a <abbr>GHC</abbr> compiler plugin. This is demonstrated by the related <a href="http://hackage.haskell.org/package/apply-unordered">apply-unordered package</a>.</p><h2 id="type-directed-application-of-a-single-argument"><a href="#type-directed-application-of-a-single-argument"></a>Type-directed application of a single argument</h2><p>A step towards a solution to this is to write a function which implements type-directed application of a single argument. Lets name this function <code>(?)</code>, used like this:</p><div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="ot">appendEllo ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>appendEllo <span class="ot">=</span> T.cons <span class="op">?</span> ello</span></code></pre></div><p><code>(?)</code> takes any function <code>f</code>, and an argument <code>a</code> that matches the type of one of its parameters. It will then partially apply <code>f</code> to this argument. So, the example above is equivalent to:</p><div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="ot">appendEllo ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>appendEllo <span class="ot">=</span> (\a arg1 <span class="ot">-&gt;</span> T.cons arg1 a) ello</span></code></pre></div><p><code>(?)</code> should also be able to provide a value for the first parameter:</p><div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="ot">prependH ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>prependH <span class="ot">=</span> T.cons <span class="op">?</span> <span class="ch">'h'</span></span></code></pre></div><p>The plan is to automatically construct this code by using typeclass machinery!</p><h2 id="a-failed-attempt"><a href="#a-failed-attempt"></a>A failed attempt</h2><p>One way to approach this might be a typeclass with an associated type family for the result:</p><div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">class</span> <span class="dt">ApplyByType</span> a f <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>  <span class="kw">type</span> <span class="dt">ApplyByTypeResult</span> a f</span>
<span id="cb5-3"><a href="#cb5-3"></a>  (<span class="op">?</span>)</span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="ot">    ::</span> f</span>
<span id="cb5-5"><a href="#cb5-5"></a>    <span class="ot">-&gt;</span> a</span>
<span id="cb5-6"><a href="#cb5-6"></a>    <span class="ot">-&gt;</span> <span class="dt">ApplyByTypeResult</span> a f</span></code></pre></div><p>The type-level algorithm implemented by these instances should check if the first parameter of <code>f</code> matches <code>a</code>. If it does, then apply the function:</p><div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">instance</span> <span class="dt">ApplyByType</span> a (a <span class="ot">-&gt;</span> r) <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>  <span class="kw">type</span> <span class="dt">ApplyByTypeResult</span> a (a <span class="ot">-&gt;</span> r) <span class="ot">=</span> r</span>
<span id="cb6-3"><a href="#cb6-3"></a>  f <span class="op">?</span> x <span class="ot">=</span> f x</span></code></pre></div><p>If it doesn't, then it should recurse down the right-hand-side of the <code>(-&gt;)</code> type:</p><div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">instance</span> <span class="dt">ApplyByType</span> a r <span class="ot">=&gt;</span> <span class="dt">ApplyByType</span> a (b <span class="ot">-&gt;</span> r) <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>  <span class="kw">type</span> <span class="dt">ApplyByTypeResult</span> a (b <span class="ot">-&gt;</span> r) <span class="ot">=</span> b <span class="ot">-&gt;</span> <span class="dt">ApplyByTypeResult</span> a r</span>
<span id="cb7-3"><a href="#cb7-3"></a>  f <span class="op">?</span> y <span class="ot">=</span> \x <span class="ot">-&gt;</span> f x <span class="op">?</span> y</span></code></pre></div><p>However, this doesn't work! <abbr>GHC</abbr> complains:</p><div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="dt">Conflicting</span> <span class="kw">family</span> <span class="kw">instance</span> declarations<span class="op">:</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>  <span class="dt">ApplyByTypeResult</span> a (a <span class="ot">-&gt;</span> r) <span class="ot">=</span> r</span>
<span id="cb8-3"><a href="#cb8-3"></a>  <span class="dt">ApplyByTypeResult</span> a (b <span class="ot">-&gt;</span> r) <span class="ot">=</span> b <span class="ot">-&gt;</span> <span class="dt">ApplyByTypeResult</span> a r</span></code></pre></div><p>The problem is that open type families do not allow overlap in their instances.</p><p>The code that results in this error is <a href="https://github.com/mgsloan/apply-unordered/blob/master/didactic/v1.hs">didactic/v1.hs on github</a>.</p><h2 id="attempted-fix-use-a-closed-type-family"><a href="#attempted-fix-use-a-closed-type-family"></a>Attempted fix: use a closed type family</h2><p><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/exts/type_families.html#closed-type-families">Closed type families</a> permit such overlap, and so provide a nice workaround for this problem. Here's what using a closed type family might look like:</p><div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">ApplyByTypeResult</span> a f <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>  <span class="dt">ApplyByTypeResult</span> a (a <span class="ot">-&gt;</span> r) <span class="ot">=</span> r</span>
<span id="cb9-3"><a href="#cb9-3"></a>  <span class="dt">ApplyByTypeResult</span> a (b <span class="ot">-&gt;</span> r) <span class="ot">=</span> b <span class="ot">-&gt;</span> <span class="dt">ApplyByTypeResult</span> a r</span></code></pre></div><p>This can be tried out in <abbr>GHCi</abbr>, by using <code>:k!</code> to ask <abbr>GHC</abbr> to normalize the type – expanding synonyms and applying type functions:</p><div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="op">&gt;</span> <span class="op">:</span>k<span class="op">!</span> <span class="dt">ApplyByTypeResult</span> <span class="dt">Text</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span>)</span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="dt">ApplyByTypeResult</span> <span class="dt">Text</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span>)<span class="ot"> ::</span> <span class="op">*</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="ot">=</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></span></code></pre></div><p>Awesome! It's figured out that <code>Text</code> matches the second parameter, and so unordered partial application results in a <code>Char -&gt; Text</code> type.</p><p>Trying it along with the typeclass:</p><div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">class</span> <span class="dt">ApplyByType</span> a f <span class="kw">where</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="ot">  (?) ::</span> f <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ApplyByTypeResult</span> a f</span>
<span id="cb11-3"><a href="#cb11-3"></a></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="kw">instance</span> <span class="dt">ApplyByType</span> a (a <span class="ot">-&gt;</span> r) <span class="kw">where</span></span>
<span id="cb11-5"><a href="#cb11-5"></a>  f <span class="op">?</span> x <span class="ot">=</span> f x</span>
<span id="cb11-6"><a href="#cb11-6"></a></span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="kw">instance</span> <span class="dt">ApplyByType</span> a r <span class="ot">=&gt;</span> <span class="dt">ApplyByType</span> a (b <span class="ot">-&gt;</span> r) <span class="kw">where</span></span>
<span id="cb11-8"><a href="#cb11-8"></a>  f <span class="op">?</span> y <span class="ot">=</span> \x <span class="ot">-&gt;</span> f x <span class="op">?</span> y</span></code></pre></div><p>Argh! Foiled again:</p><div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a>• <span class="dt">Couldn't</span> match expected <span class="kw">type</span> ‘<span class="dt">ApplyByTypeResult</span> a (b <span class="ot">-&gt;</span> r)’</span>
<span id="cb12-2"><a href="#cb12-2"></a>              with actual <span class="kw">type</span> ‘b <span class="ot">-&gt;</span> <span class="dt">ApplyByTypeResult</span> a r’</span>
<span id="cb12-3"><a href="#cb12-3"></a>• <span class="dt">The</span> lambda expression ‘\ x <span class="ot">-&gt;</span> f x <span class="op">?</span> y’</span>
<span id="cb12-4"><a href="#cb12-4"></a>  has one argument,</span>
<span id="cb12-5"><a href="#cb12-5"></a>  but its <span class="kw">type</span> ‘<span class="dt">ApplyByTypeResult</span> a (b <span class="ot">-&gt;</span> r)’ has none</span>
<span id="cb12-6"><a href="#cb12-6"></a>  <span class="op">...</span></span></code></pre></div><p>I think the problem here is that <abbr>GHC</abbr> has insufficient information to choose between the different cases of the closed type family. In order to reject the first equation, it would need to know that <code>a</code> does not unify with <code>b</code>.</p><p>The code that results in this error is <a href="https://github.com/mgsloan/apply-unordered/blob/master/didactic/v2.hs">didactic/v2.hs on github</a>.</p><h2 id="fix-use-a-closed-type-family-to-choose-the-instance"><a href="#fix-use-a-closed-type-family-to-choose-the-instance"></a>Fix: use a closed type family to choose the instance!</h2><p>A well-known trick among typeclass machinery enthusiasts is to use a closed type family to choose an instance. Here's how this works:</p><ol><li><p>A type parameter is added to the typeclass, which is used to select the instance.</p></li><li><p>A <code>Proxy</code> parameter is added to the method(s), used to specify the type parameter when using the class.</p></li><li><p>A closed type family is used to compute the type to pass in via the <code>Proxy</code>.</p></li></ol><p>Here's what it looks like for this application:</p><div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">data</span> <span class="dt">MatchArgResult</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>  <span class="ot">=</span> <span class="dt">Matches</span></span>
<span id="cb13-3"><a href="#cb13-3"></a>  <span class="op">|</span> <span class="dt">Doesn'tMatch</span></span>
<span id="cb13-4"><a href="#cb13-4"></a>  <span class="op">|</span> <span class="dt">NoArgToMatch</span></span>
<span id="cb13-5"><a href="#cb13-5"></a></span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">MatchFirstArg</span> a<span class="ot"> f ::</span> <span class="dt">MatchArgResult</span> <span class="kw">where</span></span>
<span id="cb13-7"><a href="#cb13-7"></a>  <span class="dt">MatchFirstArg</span> a (a <span class="ot">-&gt;</span> r) <span class="ot">=</span> <span class="dt">'Matches</span></span>
<span id="cb13-8"><a href="#cb13-8"></a>  <span class="dt">MatchFirstArg</span> a (b <span class="ot">-&gt;</span> r) <span class="ot">=</span> <span class="dt">'Doesn'tMatch</span></span>
<span id="cb13-9"><a href="#cb13-9"></a>  <span class="dt">MatchFirstArg</span> _ _ <span class="ot">=</span> <span class="dt">'NoArgToMatch</span></span></code></pre></div><p>The <code>MatchArgResult</code> constructors are used at the type-level via the <code>DataKinds</code> extension. This is not really necessary, but it's rather nice for having a proper type-level datatype to use for the result of the discriminating closed type family.</p><p>Trying it out in <abbr>GHCi</abbr>:</p><div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a><span class="op">&gt;</span> <span class="op">:</span>k<span class="op">!</span> <span class="dt">MatchFirstArg</span> <span class="dt">Char</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span>)</span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="dt">MatchFirstArg</span> <span class="dt">Char</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span>)<span class="ot"> ::</span> <span class="dt">MatchArgResult</span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="ot">=</span> <span class="dt">'Matches</span></span>
<span id="cb14-4"><a href="#cb14-4"></a></span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="op">&gt;</span> <span class="op">:</span>k<span class="op">!</span> <span class="dt">MatchFirstArg</span> <span class="dt">Text</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span>)</span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="dt">MatchFirstArg</span> <span class="dt">Text</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span>)<span class="ot"> ::</span> <span class="dt">MatchArgResult</span></span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="ot">=</span> <span class="dt">'Doesn'tMatch</span></span>
<span id="cb14-8"><a href="#cb14-8"></a></span>
<span id="cb14-9"><a href="#cb14-9"></a><span class="op">&gt;</span> <span class="op">:</span>k<span class="op">!</span> <span class="dt">MatchFirstArg</span> <span class="dt">Char</span> <span class="dt">Text</span></span>
<span id="cb14-10"><a href="#cb14-10"></a><span class="dt">MatchFirstArg</span> <span class="dt">Char</span> <span class="dt">Text</span><span class="ot"> ::</span> <span class="dt">MatchArgResult</span></span>
<span id="cb14-11"><a href="#cb14-11"></a><span class="ot">=</span> <span class="dt">'NoArgToMatch</span></span></code></pre></div><p>It works! When the argument type matches the first parameter, the result is <code>Matches</code>, and when it does not, the result is <code>Doesn'tMatch</code>. When it isn't a function at all, the result is <code>NoArgToMatch</code>.</p><p>This closed type family will allow us to choose between <code>ApplyByTypeResult</code> instances, avoiding any overlap issues. The method also gets renamed to <code>applyByTypeImpl</code>, as the <code>(?)</code> function will get defined in terms of it:</p><div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">class</span> <span class="dt">ApplyByType</span> (<span class="ot">matches ::</span> <span class="dt">MatchArgResult</span>) a f <span class="kw">where</span></span>
<span id="cb15-2"><a href="#cb15-2"></a>  <span class="kw">type</span> <span class="dt">ApplyByTypeResult</span> matches a f</span>
<span id="cb15-3"><a href="#cb15-3"></a>  applyByTypeImpl</span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="ot">    ::</span> <span class="dt">Proxy</span> matches</span>
<span id="cb15-5"><a href="#cb15-5"></a>    <span class="ot">-&gt;</span> f</span>
<span id="cb15-6"><a href="#cb15-6"></a>    <span class="ot">-&gt;</span> a</span>
<span id="cb15-7"><a href="#cb15-7"></a>    <span class="ot">-&gt;</span> <span class="dt">ApplyByTypeResult</span> matches a f</span>
<span id="cb15-8"><a href="#cb15-8"></a></span>
<span id="cb15-9"><a href="#cb15-9"></a><span class="kw">instance</span> <span class="dt">ApplyByType</span> <span class="dt">'Matches</span> a (a <span class="ot">-&gt;</span> r) <span class="kw">where</span></span>
<span id="cb15-10"><a href="#cb15-10"></a>  <span class="kw">type</span> <span class="dt">ApplyByTypeResult</span> <span class="dt">'Matches</span> a (a <span class="ot">-&gt;</span> r) <span class="ot">=</span> r</span>
<span id="cb15-11"><a href="#cb15-11"></a>  applyByTypeImpl _ f x <span class="ot">=</span> f x</span></code></pre></div><p>The recursive case gets a little trickier:</p><div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">instance</span> <span class="dt">ApplyByType</span> (<span class="dt">MatchFirstArg</span> a r) a r</span>
<span id="cb16-2"><a href="#cb16-2"></a>      <span class="ot">=&gt;</span> <span class="dt">ApplyByType</span> <span class="dt">'Doesn'tMatch</span> a (b <span class="ot">-&gt;</span> r) <span class="kw">where</span></span>
<span id="cb16-3"><a href="#cb16-3"></a>  <span class="kw">type</span> <span class="dt">ApplyByTypeResult</span> <span class="dt">'Doesn'tMatch</span> a (b <span class="ot">-&gt;</span> r) <span class="ot">=</span></span>
<span id="cb16-4"><a href="#cb16-4"></a>    b <span class="ot">-&gt;</span> <span class="dt">ApplyByTypeResult</span> (<span class="dt">MatchFirstArg</span> a r) a r</span>
<span id="cb16-5"><a href="#cb16-5"></a>  applyByTypeImpl _ f y <span class="ot">=</span></span>
<span id="cb16-6"><a href="#cb16-6"></a>    \x <span class="ot">-&gt;</span> applyByTypeImpl (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">MatchFirstArg</span> a r)) (f x) y</span></code></pre></div><p>In 3 different places we need to apply the <code>MatchFirstArg</code> type function in order to discriminate which instance to recurse into. It might be helpful to reference the old simpler (but non-functioning) definition:</p><div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">instance</span> <span class="dt">ApplyByType</span> a r</span>
<span id="cb17-2"><a href="#cb17-2"></a>      <span class="ot">=&gt;</span> <span class="dt">ApplyByType</span> a (b <span class="ot">-&gt;</span> r) <span class="kw">where</span></span>
<span id="cb17-3"><a href="#cb17-3"></a>  <span class="kw">type</span> <span class="dt">ApplyByTypeResult</span> a (b <span class="ot">-&gt;</span> r) <span class="ot">=</span></span>
<span id="cb17-4"><a href="#cb17-4"></a>    b <span class="ot">-&gt;</span> <span class="dt">ApplyByTypeResult</span> a r</span>
<span id="cb17-5"><a href="#cb17-5"></a>  f <span class="op">?</span> y <span class="ot">=</span></span>
<span id="cb17-6"><a href="#cb17-6"></a>    \x <span class="ot">-&gt;</span> f x <span class="op">?</span> y</span></code></pre></div><p>Giving this new definition a try:</p><div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1"></a>λ applyByTypeImpl (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">'Doesn'tMatch</span>) T.cons (<span class="st">"ello"</span><span class="ot"> ::</span> <span class="dt">T.Text</span>) <span class="op">$</span> <span class="ch">'h'</span></span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="st">"hello"</span></span></code></pre></div><p>Woohoo! It figured out that <code>"ello" :: T.Text</code> needs to be passed in as the second argument to <code>T.cons</code>.</p><p>However, it's a bit inconvenient to need to pass in that <code>Proxy</code>. The convenience of <code>(?)</code> can be regained by writing a helper function which applies <code>MatchFirstArg</code>:</p><div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1"></a>(<span class="op">?</span>)</span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="ot">  ::</span> <span class="kw">forall</span> matches a f<span class="op">.</span></span>
<span id="cb19-3"><a href="#cb19-3"></a>     ( matches <span class="op">~</span> <span class="dt">MatchFirstArg</span> a f</span>
<span id="cb19-4"><a href="#cb19-4"></a>     , <span class="dt">ApplyByType</span> matches a f</span>
<span id="cb19-5"><a href="#cb19-5"></a>     )</span>
<span id="cb19-6"><a href="#cb19-6"></a>  <span class="ot">=&gt;</span> f <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ApplyByTypeResult</span> matches a f</span>
<span id="cb19-7"><a href="#cb19-7"></a>(<span class="op">?</span>) <span class="ot">=</span> applyByTypeImpl (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> matches)</span></code></pre></div><p>Giving that a try:</p><div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1"></a><span class="op">&gt;</span> T.cons <span class="op">?</span> T.pack <span class="st">"ello"</span> <span class="op">?</span> <span class="ch">'h'</span></span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="st">"hello"</span></span></code></pre></div><p>Boom! Unordered, type-directed function application!</p><p>This version of the code is <a href="https://github.com/mgsloan/apply-unordered/blob/master/didactic/v3.hs">didactic/v3.hs on github</a>. The next post in this series will improve the type errors that occur when the argument type mismatches with all of the parameters.</p><h2 id="appendix-why"><a href="#appendix-why"></a>Appendix: Why?</h2><p>You might be wondering why you would ever want to use this. Honestly, I can't think of many practical applications, and so the <a href="http://hackage.haskell.org/package/apply-unordered-mono">apply-unordered-mono package</a> is in the <a href="http://hackage.haskell.org/packages/#cat:ACME"><code>ACME</code> category</a> on Hackage. Even so, I think it's pretty cool that this is possible.</p><p>One potential use-case might be to handle shifting APIs in dependencies. If a library changes the order of its arguments, you might be able to use the <code>(?)</code> operator to be compatible with versions before and after this change, without using the C preprocessor.</p><p>The inspiration for this package was speculation about a programming language where arguments are discriminated by type instead of position. To experiment with this, it turned out to be more straightforward to directly implement the idea in Haskell rather than writing a whole new language. Here are some reasons why I think this is an interesting idea for language design:</p><ul><li><p>Parameter order is often arbitrary, and so requires effort to memorize.</p></li><li><p>It is safer to have distinct types for all arguments, to avoid bugs due to inadvertent transposition.</p></li></ul><p>Named parameters can help with this, but then you need to memorize the names! Conventions where the name is the same as the type adds verbosity / redundancy.</p><p>In practice, many newtypes would be involved in usage of type-directed application. Newtypes might even be associated with the function definition, to provide something akin to named parameters.</p><p>Ordered arguments do have some nice advantages, though:</p><ul><li><p>Polymorphism. Matching of arguments with parameters gets ambiguous when type variables are involved.</p></li><li><p>Ordered arguments provides more direct visual comparison of calls of the same function.</p></li></ul><p>To me, this suggests an alternative implementation approach. Rather than incorporating type-directed application directly into the language, or as a library, it can be part of edit-time tooling. For example, the reformatting tool might handle reordering the arguments.</p></article><section id="teaser-section"><div id="teaser"><p class="smcp">More words</p><h2><a href="/posts/polarizer-glasses">Polarizer Glasses for Outdoor Computing</a></h2><p>I built some variable angle polarizer glasses based on camera optics! <a href="/posts/polarizer-glasses" class="smcp">Read</a></p></div></section><footer><div id="footer"><p id="notices" class="smcp"><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Copyleft 2018-2021</a> <span id="breakdot">·</span> <a rel="author" href="https://mgsloan.com">Michael G Sloan</a> <span id="breakdot">·</span> <a href="https://github.com/mgsloan/mgsloan-site">Site Code</a> <span id="breakdot">·</span> <a href="/feed.xml">Feed</a></p><p id="profile-links" class="smcp"><a href="https://github.com/mgsloan">GitHub</a> <span id="breakdot">·</span> <a href="https://twitter.com/treetopian">Twitter</a></p></div></footer><dark-mode-toggle></dark-mode-toggle><script type="module" src="/dark-mode-toggle.mjs"></script><script>const toggle = document.querySelector('dark-mode-toggle'); const html = document.documentElement; toggle.addEventListener('colorschemechange', () => { html.classList.toggle('dark', toggle.mode === 'dark'); });</script></body></html>